/*
 *   DI_2108_P class, used for communicating with DATAQ Model DI-2108-P High
 *   Speed DAQ.
 *
 *   Uses libusb to communicate with device.
 *
 *   Developed by Sam de Jong
 */


#include <iostream>
#include <stdio.h>
#include <string.h>
#include <sstream>
#include <unistd.h>
#include <vector>
#include </usr/include/libusb-1.0/libusb.h>

#include "DI-2108-P.h"

using namespace std;


DI_2108_P::DI_2108_P(){
  nChan=1;
  ranges.resize(nChan);
  multiplier.resize(nChan);
  divisor.resize(nChan);
  isRun=false;
  isRecording=false;
  isInit=false;
}

DI_2108_P::DI_2108_P(int nChannels){
  nChan=nChannels;
  ranges.resize(nChan);
  multiplier.resize(nChan);
  divisor.resize(nChan);
  isRun=false;
  isRecording=false;
  isInit=false;
}


void DI_2108_P::Initialize(){
  isInit=true;
  libusb_device **devs; //pointer to pointer of device, used to retrieve a list of devices
  //libusb_device_handle *dev_handle; //a device handle
  ctx = NULL; //a libusb session
  int r; //for return values
  ssize_t cnt; //holding number of devices in list
  r = libusb_init(&ctx); //initialize the library for the session we just declared
  if(r < 0) {
    cout<<"Init Error "<<r<<endl; //there was an error
    isInit=false;
    return;
    //return error;
  }
  libusb_set_debug(ctx, 3); //set verbosity level to 3, as suggested in the documentation
  
  cnt = libusb_get_device_list(ctx, &devs); //get the list of devices
  if(cnt < 0) {
    cout<<"Get Device Error"<<endl; //there was an error
    isInit=false;
    return;
    
    //return error;
  }
  cout<<cnt<<" Devices in list."<<endl;
  
  dev_handle = libusb_open_device_with_vid_pid(ctx, vID, pID); //these are vendorID and productID I found for my usb device
  if(dev_handle == NULL){
    cout<<"Cannot open device"<<endl;
    isInit=false;
    return;
  }
  else
    cout<<"Device Opened"<<endl;
  libusb_free_device_list(devs, 1); //free the list, unref the devices in it
  
  if(libusb_kernel_driver_active(dev_handle, 0) == 1) { //find out if kernel driver is attached
    cout<<"Kernel Driver Active"<<endl;
    if(libusb_detach_kernel_driver(dev_handle, 0) == 0) //detach it
      cout<<"Kernel Driver Detached!"<<endl;
  }
  r = libusb_claim_interface(dev_handle, 0); //claim interface 0 (the first) of device (mine had jsut 1)
  if(r < 0) {
    cout<<"Cannot Claim Interface"<<endl;
    return;
  }
  cout<<"Claimed Interface"<<endl;
    
    
}

void DI_2108_P::reset(){
  libusb_reset_device(dev_handle);
  isRun=false;	
}


void DI_2108_P::close(){
  int r;
  //libusb_context *ctx = NULL; //a libusb session
  
  r = libusb_release_interface(dev_handle, 0); //release the claimed interface
  if(r!=0) {
    cout<<"Cannot Release Interface"<<endl;
    return;
  }
  cout<<"Released Interface"<<endl;
  
  libusb_close(dev_handle); //close the device we opened
  libusb_exit(ctx); //needs to be called to end the
 

}


string DI_2108_P::sendMessage(string message){
  //libusb_context *ctx = NULL; //a libusb session
  if(!isInit) return "error\n";
  
  int r; //for return values

  string error = "error";

  message = message+"\r";
  

  unsigned char recieved[1000000];
  unsigned char sent[50];
  strcpy((char*) sent, message.c_str());
  

  int actual; //used to find out how many bytes were written
  
  //cout<<"Data->"<<message<<"<-"<<endl; //just to see the data we want to write : abcd
  //cout<<"Writing Data..."<<endl;
  r = libusb_bulk_transfer(dev_handle, (1 | LIBUSB_ENDPOINT_OUT), sent, sizeof(sent), &actual, 0); 

  if(r == 0 && actual == sizeof(sent)){ //we wrote the 4 bytes successfully
    //cout<<"Writing Successful!"<<endl;
    sleep(0.1);
    r = libusb_bulk_transfer(dev_handle, (1 | LIBUSB_ENDPOINT_IN), recieved, sizeof(recieved), &actual, 0);
    
  }else {
    cout<<"Write Error"<<endl;
    return libusb_strerror((libusb_error)r);
  }
  std::string sName(reinterpret_cast<char*>(recieved));
  return sName;


}

void DI_2108_P::setNChannels(int nChannels){
  nChan = nChannels;
  ranges.resize(nChan);
  multiplier.resize(nChan);
  divisor.resize(nChan);
}

void DI_2108_P::setRange(int channel, int range){
  if(channel>nChan) return;
  if(range>4) return;
  ranges[channel] = range;

  if(range==0){
    multiplier[channel]=10;
    divisor[channel] = 1./32768;
  }else if(range==1){
    multiplier[channel]=5;
    divisor[channel] = 1./32768;
  }else if(range==2){
    multiplier[channel]=2.5;
    divisor[channel] = 1./32768;
  }else if(range==3){
    multiplier[channel]=10;
    divisor[channel] = 1./65536;
  }else if(range==4){
    multiplier[channel]=5;
    divisor[channel] = 1./65536;
  }
}


void DI_2108_P::startScan(){
  this->sendMessage("ps 1");

  stringstream ss;
  for(int i=0; i<nChan; i++){
    ss<<i;
    string slistString = "slist "+ss.str()+" ";;
    ss.str("");

    int b=ranges[i]<<8;
    
    int channelMask = i+b;
    ss<<channelMask;
    slistString = slistString+ss.str();
    ss.str("");
    
    this->sendMessage(slistString);

    cout<<slistString<<endl;
        
  }





  this->sendMessage("start 0");
  isRun=true;

}

void DI_2108_P::stopScan(){
  isRun=false;
  this->sendMessage("stop 0");

}



vector<double> DI_2108_P::getReadings(){
  
  isRecording=true;

  vector<double> readings;
  readings.resize(8);
  
  if(!isInit) return readings;

  int r; //for return values

  unsigned char recieved[1000000];
    
  int actual; //used to find out how many bytes were written
  
  r = libusb_bulk_transfer(dev_handle, (1 | LIBUSB_ENDPOINT_IN), recieved, 1000000, &actual, 0);

  for(int i=0; i<nChan; i++){
    short combined = (recieved[2*i+1] << 8 ) | (recieved[2*i] & 0xff);
    
    double add = 0;
    if(ranges[i]>2) add=multiplier[i]/2;
    
    readings[i] = multiplier[i]*(double)combined*divisor[i]+add;
   

  }
  
  isRecording=false;

  return readings;

  
}
 
